{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview \u00b6 This site documents extensions for OCFL (the Oxford Common File Layout ) defined by DANS for use in the DANS Data Vault. Object Version Properties - specifies how to document additional properties for a OCFL object version. Property Registry - specifies properties and their definitions and structure. Packaging Format Registry - specifies how to document how the content files of OCFL object versions are packaged.","title":"Overview"},{"location":"#overview","text":"This site documents extensions for OCFL (the Oxford Common File Layout ) defined by DANS for use in the DANS Data Vault. Object Version Properties - specifies how to document additional properties for a OCFL object version. Property Registry - specifies properties and their definitions and structure. Packaging Format Registry - specifies how to document how the content files of OCFL object versions are packaged.","title":"Overview"},{"location":"arch/","text":"DANS Data Station Architecture \u00b6 This module is a component in the DANS Data Station Architecture .","title":"\u21d2 DANS Data Station Architecture"},{"location":"arch/#dans-data-station-architecture","text":"This module is a component in the DANS Data Station Architecture .","title":"DANS Data Station Architecture"},{"location":"examples/","text":"Overview \u00b6 Collaboration - gives examples how to combine Object Version Properties, Packaging Format Registry and Property Registry.","title":"Overview"},{"location":"examples/#overview","text":"Collaboration - gives examples how to combine Object Version Properties, Packaging Format Registry and Property Registry.","title":"Overview"},{"location":"collaboration/","text":"Collaboration of these three OCFL Extensions \u00b6 This document gives an example of a way to combine the three OCFL extensions to achieve a way to prescribe the properties to be recorded and how to record them for each OCFL object version. Repository layout \u00b6 In this example, the OCFL repository is structured as follows: [storage_root] \u251c\u2500\u2500 0=ocfl_1.0 \u251c\u2500\u2500 ocfl_1.0.txt \u251c\u2500\u2500 ocfl_layout.json \u251c\u2500\u2500 object-version-properties.md \u251c\u2500\u2500 packaging-format-registry.md \u251c\u2500\u2500 property-registry.md \u251c\u2500\u2500 extensions | \u251c\u2500\u2500 property-registry/ | | \u2514\u2500\u2500 config.json \u2502 \u2514\u2500\u2500 packaging-format-registry/ \u2502 \u251c\u2500\u2500 config.json | \u251c\u2500\u2500 packaging_format_inventory.json | \u251c\u2500\u2500 packaging_format_inventory.json.sha512 \u2502 \u2514\u2500\u2500 packaging_formats \u2502 \u251c\u2500\u2500 05b408a38e341de9bb4316aa812115ee \u2502 \u2502 \u2514\u2500\u2500 ... files describing the packaging_format BagIt/v1.0 ... \u2502 \u251c\u2500\u2500 76f773808534f2969d7a405b99e78b11 \u2502 \u2502 \u2514\u2500\u2500 ... files describing the packaging_format BagIt/v0.97 ... \u2502 \u2514\u2500\u2500 15e5e7397258f296a04219bce1defdff \u2502 \u2514\u2500\u2500 ... files describing the packaging_format DANS BagPack Profile/v1.0.0 \u251c\u2500\u2500 0de | \u2514\u2500\u2500 45c | \u2514\u2500\u2500 f24 | \u2514\u2500\u2500 item1 \u2502 \u2514\u2500\u2500 0=ocfl_object_1.0 \u2502 \u251c\u2500\u2500 inventory.json \u2502 \u251c\u2500\u2500 inventory.json.sha512 | \u2514\u2500\u2500 extensions \u2502 \u2514\u2500\u2500 object-version-properties/ \u2502 \u251c\u2500\u2500 object_version_properties.json \u2502 \u2514\u2500\u2500 object_version_properties.json.sha512 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v1/ \u2502 \u251c\u2500\u2500 inventory.json \u2502 \u251c\u2500\u2500 inventory.json.sha512 \u2502 \u2514\u2500\u2500 content/ \u2502 \u2514\u2500\u2500 ... files ... \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v2/ \u2502 \u251c\u2500\u2500 inventory.json \u2502 \u251c\u2500\u2500 inventory.json.sha512 \u2502 \u2514\u2500\u2500 content/ \u2502 \u2514\u2500\u2500 ... files ... Content of the extensions \u00b6 Property registry \u00b6 The config.json file in the property-registry extension declares the properties that can be used in the object_version_properties.json file of an OCFL object version. { \"extensionName\" : \"property-registry\" , \"propertyRegistry\" : { \"retentionEndDate\" : { \"description\" : \"the date until which this object version may be retained in this repository\" , \"type\" : \"string\" , \"constraint\" : \"a date in ISO 8601 format, e.g. 2030-10-01\" , \"required\" : false }, \"deaccessioned\" : { \"description\" : \"If present, this version of the object has been deaccessioned and should not be disseminated\" , \"type\" : \"object\" , \"required\" : false , \"properties\" : [ { \"name\" : \"datetime\" , \"description\" : \"The date on which this object version has been deaccessioned\" , \"type\" : \"string\" , \"constraint\" : \"a datetime in ISO 8601 YYYY-MM-DDTHH-mm-ss format\" , \"required\" : true }, { \"name\" : \"reason\" , \"description\" : \"The reason why this object version has been deaccessioned.\" , \"type\" : \"string\" , \"required\" : true } ] } }, \"packagingFormat\" : { \"description\" : \"The packaging format of the current object version, as defined in the packaging-format-registry\" , \"type\" : \"string\" , \"required\" : true } } Packaging format registry \u00b6 The config.json file in the packaging-format-registry extension defines how to document the available OCFL Object Packaging Formats. { \"extensionName\" : \"packaging-format-registry\" , \"digestAlgorithm\" : \"sha512\" , \"packagingFormatDigestAlgorithm\" : \"md5\" } The packaging_format_inventory.json file in the packaging-format-registry extension contains the manifest with the available OCFL Object Packaging Formats for this OCFL Repository. { \"manifest\" : { \"76f773808534f2969d7a405b99e78b11\" : { \"name\" : \"BagIt\" , \"version\" : \"v0.97\" , \"summary\" : \"a hierarchical file packaging format for storage and transfer of arbitrary digital content.\" }, \"05b408a38e341de9bb4316aa812115ee\" : { \"name\" : \"BagIt\" , \"version\" : \"v1.0\" , \"summary\" : \"https://datatracker.ietf.org/doc/html/rfc8493\" }, \"15e5e7397258f296a04219bce1defdff\" : { \"name\" : \"DANS BagPack Profile\" , \"version\" : \"v1.0.0\" , \"summary\" : \"A DANS specific profile for the BagPack packaging format.\" } } } The names of the manifest entries are the digests of name + / + version of the packaging format, using the digestAlgorithm defined in the config.json , e.g., echo -n \"BagIt/v1.0\" | md5sum # Output: 05b408a38e341de9bb4316aa812115ee The files documenting the packaging formats are stored in the subdirectories with the same names. Object version properties \u00b6 If the object in the example repository had two versions the object_version_properties.json file might look like this: { \"v2\" : { \"retentionEndDate\" : \"2071-03-18\" , \"packaging-format\" : \"DANS BagPack Profile/v1.0.0\" }, \"v1\" : { \"retentionEndDate\" : \"2071-03-18\" , \"packaging-format\" : \"DANS BagPack Profile/v1.0.0\" , \"deaccessioned\" : { \"datetime\" : \"2025-12-31T13:55:00\" , \"reason\" : \"Deaccessioned because confidential data was removed\" } } } Both versions have a retentionEndDate of 2071-03-18 , which is the date until which this object version may be retained in this repository. Both are packaged using the DANS BagPack Profile/v1.0.0 packaging format, which is defined in the packaging-format-registry extension. The first version was deaccessioned on 2025-12-31T13:55:00 because confidential data was removed, and should not be disseminated.","title":"Collaboration"},{"location":"collaboration/#collaboration-of-these-three-ocfl-extensions","text":"This document gives an example of a way to combine the three OCFL extensions to achieve a way to prescribe the properties to be recorded and how to record them for each OCFL object version.","title":"Collaboration of these three OCFL Extensions"},{"location":"collaboration/#repository-layout","text":"In this example, the OCFL repository is structured as follows: [storage_root] \u251c\u2500\u2500 0=ocfl_1.0 \u251c\u2500\u2500 ocfl_1.0.txt \u251c\u2500\u2500 ocfl_layout.json \u251c\u2500\u2500 object-version-properties.md \u251c\u2500\u2500 packaging-format-registry.md \u251c\u2500\u2500 property-registry.md \u251c\u2500\u2500 extensions | \u251c\u2500\u2500 property-registry/ | | \u2514\u2500\u2500 config.json \u2502 \u2514\u2500\u2500 packaging-format-registry/ \u2502 \u251c\u2500\u2500 config.json | \u251c\u2500\u2500 packaging_format_inventory.json | \u251c\u2500\u2500 packaging_format_inventory.json.sha512 \u2502 \u2514\u2500\u2500 packaging_formats \u2502 \u251c\u2500\u2500 05b408a38e341de9bb4316aa812115ee \u2502 \u2502 \u2514\u2500\u2500 ... files describing the packaging_format BagIt/v1.0 ... \u2502 \u251c\u2500\u2500 76f773808534f2969d7a405b99e78b11 \u2502 \u2502 \u2514\u2500\u2500 ... files describing the packaging_format BagIt/v0.97 ... \u2502 \u2514\u2500\u2500 15e5e7397258f296a04219bce1defdff \u2502 \u2514\u2500\u2500 ... files describing the packaging_format DANS BagPack Profile/v1.0.0 \u251c\u2500\u2500 0de | \u2514\u2500\u2500 45c | \u2514\u2500\u2500 f24 | \u2514\u2500\u2500 item1 \u2502 \u2514\u2500\u2500 0=ocfl_object_1.0 \u2502 \u251c\u2500\u2500 inventory.json \u2502 \u251c\u2500\u2500 inventory.json.sha512 | \u2514\u2500\u2500 extensions \u2502 \u2514\u2500\u2500 object-version-properties/ \u2502 \u251c\u2500\u2500 object_version_properties.json \u2502 \u2514\u2500\u2500 object_version_properties.json.sha512 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v1/ \u2502 \u251c\u2500\u2500 inventory.json \u2502 \u251c\u2500\u2500 inventory.json.sha512 \u2502 \u2514\u2500\u2500 content/ \u2502 \u2514\u2500\u2500 ... files ... \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v2/ \u2502 \u251c\u2500\u2500 inventory.json \u2502 \u251c\u2500\u2500 inventory.json.sha512 \u2502 \u2514\u2500\u2500 content/ \u2502 \u2514\u2500\u2500 ... files ...","title":"Repository layout"},{"location":"collaboration/#content-of-the-extensions","text":"","title":"Content of the extensions"},{"location":"collaboration/#property-registry","text":"The config.json file in the property-registry extension declares the properties that can be used in the object_version_properties.json file of an OCFL object version. { \"extensionName\" : \"property-registry\" , \"propertyRegistry\" : { \"retentionEndDate\" : { \"description\" : \"the date until which this object version may be retained in this repository\" , \"type\" : \"string\" , \"constraint\" : \"a date in ISO 8601 format, e.g. 2030-10-01\" , \"required\" : false }, \"deaccessioned\" : { \"description\" : \"If present, this version of the object has been deaccessioned and should not be disseminated\" , \"type\" : \"object\" , \"required\" : false , \"properties\" : [ { \"name\" : \"datetime\" , \"description\" : \"The date on which this object version has been deaccessioned\" , \"type\" : \"string\" , \"constraint\" : \"a datetime in ISO 8601 YYYY-MM-DDTHH-mm-ss format\" , \"required\" : true }, { \"name\" : \"reason\" , \"description\" : \"The reason why this object version has been deaccessioned.\" , \"type\" : \"string\" , \"required\" : true } ] } }, \"packagingFormat\" : { \"description\" : \"The packaging format of the current object version, as defined in the packaging-format-registry\" , \"type\" : \"string\" , \"required\" : true } }","title":"Property registry"},{"location":"collaboration/#packaging-format-registry","text":"The config.json file in the packaging-format-registry extension defines how to document the available OCFL Object Packaging Formats. { \"extensionName\" : \"packaging-format-registry\" , \"digestAlgorithm\" : \"sha512\" , \"packagingFormatDigestAlgorithm\" : \"md5\" } The packaging_format_inventory.json file in the packaging-format-registry extension contains the manifest with the available OCFL Object Packaging Formats for this OCFL Repository. { \"manifest\" : { \"76f773808534f2969d7a405b99e78b11\" : { \"name\" : \"BagIt\" , \"version\" : \"v0.97\" , \"summary\" : \"a hierarchical file packaging format for storage and transfer of arbitrary digital content.\" }, \"05b408a38e341de9bb4316aa812115ee\" : { \"name\" : \"BagIt\" , \"version\" : \"v1.0\" , \"summary\" : \"https://datatracker.ietf.org/doc/html/rfc8493\" }, \"15e5e7397258f296a04219bce1defdff\" : { \"name\" : \"DANS BagPack Profile\" , \"version\" : \"v1.0.0\" , \"summary\" : \"A DANS specific profile for the BagPack packaging format.\" } } } The names of the manifest entries are the digests of name + / + version of the packaging format, using the digestAlgorithm defined in the config.json , e.g., echo -n \"BagIt/v1.0\" | md5sum # Output: 05b408a38e341de9bb4316aa812115ee The files documenting the packaging formats are stored in the subdirectories with the same names.","title":"Packaging format registry"},{"location":"collaboration/#object-version-properties","text":"If the object in the example repository had two versions the object_version_properties.json file might look like this: { \"v2\" : { \"retentionEndDate\" : \"2071-03-18\" , \"packaging-format\" : \"DANS BagPack Profile/v1.0.0\" }, \"v1\" : { \"retentionEndDate\" : \"2071-03-18\" , \"packaging-format\" : \"DANS BagPack Profile/v1.0.0\" , \"deaccessioned\" : { \"datetime\" : \"2025-12-31T13:55:00\" , \"reason\" : \"Deaccessioned because confidential data was removed\" } } } Both versions have a retentionEndDate of 2071-03-18 , which is the date until which this object version may be retained in this repository. Both are packaged using the DANS BagPack Profile/v1.0.0 packaging format, which is defined in the packaging-format-registry extension. The first version was deaccessioned on 2025-12-31T13:55:00 because confidential data was removed, and should not be disseminated.","title":"Object version properties"},{"location":"object-version-properties/object-version-properties/","text":"OCFL Extension: Object Version Properties \u00b6 Extension Name: object-version-properties Authors: Linda Reijnhoudt, Jan van Mansum Minimum OCFL Version: 1.0 Status: DRAFT Overview \u00b6 This extension provides a way to record properties of an OCFL object version beyond the standard properties defined by OCFL itself ( created , message , etc.). This may be useful for cases where additional information about the version is needed, which cannot conveniently be stored in the object itself in a standard way. Another use-case may be a property that is not available at the time the version content is created. This extension only describes how the properties should be recorded, it does not prescribe what properties should be recorded or their semantics. One way to define the semantics of properties is to use the Property Registry extension . The object-version-properties extension is implemented by creating and maintaining the following items: A object_version_properties.json file containing the properties for each version of the OCFL object. A sidecar file object_version_properties.json.sha512 (or other configured digest) containing the digest of the object_version_properties.json file, in the same manner as the OCFL inventory files. The digest algorithm must be the same as the one used for the OCFL inventory files. The object_version_properties.json file \u00b6 The object version properties are stored in a JSON file named object_version_properties.json in the extensions directory of the OCFL object. This file must contain entries for all versions in this object. Each version entry has as key the version identifier (e.g. v1 , v2 , etc.) and as value a JSON object with the properties for that version. If no properties are recorded for a version, the entry for that version must be an empty JSON object. The properties recorded under a version key pertain to that version only, so when a new version is created, properties that do not change must be copied from the previous version. Otherwise, this extension does not restrict the properties that can be recorded, nor does it define their semantics. Implementation \u00b6 Clients that implement this extension must validate that the object_version_properties.json file is well-formed JSON and that it contains an entry for each version in the object as part of the validation of the OCFL object. Clients may support storing the version properties when creating a new version of an OCFL object, by passing the properties map as an extra parameter to the version creation method. Likewise, clients may support retrieving the properties for a specific version of an OCFL object as a properties map. Other optional features may include the ability to search for object versions based on their properties. Examples \u00b6 1. Simple property \u00b6 If the repository wants to record a simple property, for instance the User-Agent that made the request to create this version, this could be done as follows. [storage_root] \u251c\u2500\u2500 0=ocfl_1.0 \u251c\u2500\u2500 ocfl_1.0.txt \u251c\u2500\u2500 ocfl_layout.json \u251c\u2500\u2500 object-version-properties.md \u251c\u2500\u2500 0de | \u2514\u2500\u2500 45c | \u2514\u2500\u2500 f24 | \u2514\u2500\u2500 item1 \u2502 \u2514\u2500\u2500 0=ocfl_object_1.0 \u2502 \u251c\u2500\u2500 inventory.json \u2502 \u251c\u2500\u2500 inventory.json.sha512 | \u2514\u2500\u2500 extensions \u2502 \u2514\u2500\u2500 object-version-properties/ \u2502 \u251c\u2500\u2500 object_version_properties.json \u2502 \u2514\u2500\u2500 object_version_properties.json.sha512 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v1/ \u251c\u2500\u2500 inventory.json \u251c\u2500\u2500 inventory.json.sha512 \u2514\u2500\u2500 content/ \u2514\u2500\u2500 ... files ... The object-version-properties.json of the OCFL object could have the following entry: { \"v1\" : { \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\" } } 2. Complex property \u00b6 If the repository wants to record a complex object for a version, for instance that it has been deaccessioned, this could be done with a similar structure. The object-version-properties.json of the OCFL object might have the following entry: { \"v1\" : { \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\" }, \"v2\" : { \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\" , \"deaccessioned\" : { \"datetime\" : \"2025-10-15T13:19:00\" , \"reason\" : \"Deaccessioned because dataset was deleted in Easy\" } } } Note, that this example also demonstrates that a property that remains unchanged between versions (in this case \"User-Agent\") must be copied from the previous version.","title":"Object Version Properties"},{"location":"object-version-properties/object-version-properties/#ocfl-extension-object-version-properties","text":"Extension Name: object-version-properties Authors: Linda Reijnhoudt, Jan van Mansum Minimum OCFL Version: 1.0 Status: DRAFT","title":"OCFL Extension: Object Version Properties"},{"location":"object-version-properties/object-version-properties/#overview","text":"This extension provides a way to record properties of an OCFL object version beyond the standard properties defined by OCFL itself ( created , message , etc.). This may be useful for cases where additional information about the version is needed, which cannot conveniently be stored in the object itself in a standard way. Another use-case may be a property that is not available at the time the version content is created. This extension only describes how the properties should be recorded, it does not prescribe what properties should be recorded or their semantics. One way to define the semantics of properties is to use the Property Registry extension . The object-version-properties extension is implemented by creating and maintaining the following items: A object_version_properties.json file containing the properties for each version of the OCFL object. A sidecar file object_version_properties.json.sha512 (or other configured digest) containing the digest of the object_version_properties.json file, in the same manner as the OCFL inventory files. The digest algorithm must be the same as the one used for the OCFL inventory files.","title":"Overview"},{"location":"object-version-properties/object-version-properties/#the-object_version_propertiesjson-file","text":"The object version properties are stored in a JSON file named object_version_properties.json in the extensions directory of the OCFL object. This file must contain entries for all versions in this object. Each version entry has as key the version identifier (e.g. v1 , v2 , etc.) and as value a JSON object with the properties for that version. If no properties are recorded for a version, the entry for that version must be an empty JSON object. The properties recorded under a version key pertain to that version only, so when a new version is created, properties that do not change must be copied from the previous version. Otherwise, this extension does not restrict the properties that can be recorded, nor does it define their semantics.","title":"The object_version_properties.json file"},{"location":"object-version-properties/object-version-properties/#implementation","text":"Clients that implement this extension must validate that the object_version_properties.json file is well-formed JSON and that it contains an entry for each version in the object as part of the validation of the OCFL object. Clients may support storing the version properties when creating a new version of an OCFL object, by passing the properties map as an extra parameter to the version creation method. Likewise, clients may support retrieving the properties for a specific version of an OCFL object as a properties map. Other optional features may include the ability to search for object versions based on their properties.","title":"Implementation"},{"location":"object-version-properties/object-version-properties/#examples","text":"","title":"Examples"},{"location":"object-version-properties/object-version-properties/#1-simple-property","text":"If the repository wants to record a simple property, for instance the User-Agent that made the request to create this version, this could be done as follows. [storage_root] \u251c\u2500\u2500 0=ocfl_1.0 \u251c\u2500\u2500 ocfl_1.0.txt \u251c\u2500\u2500 ocfl_layout.json \u251c\u2500\u2500 object-version-properties.md \u251c\u2500\u2500 0de | \u2514\u2500\u2500 45c | \u2514\u2500\u2500 f24 | \u2514\u2500\u2500 item1 \u2502 \u2514\u2500\u2500 0=ocfl_object_1.0 \u2502 \u251c\u2500\u2500 inventory.json \u2502 \u251c\u2500\u2500 inventory.json.sha512 | \u2514\u2500\u2500 extensions \u2502 \u2514\u2500\u2500 object-version-properties/ \u2502 \u251c\u2500\u2500 object_version_properties.json \u2502 \u2514\u2500\u2500 object_version_properties.json.sha512 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 v1/ \u251c\u2500\u2500 inventory.json \u251c\u2500\u2500 inventory.json.sha512 \u2514\u2500\u2500 content/ \u2514\u2500\u2500 ... files ... The object-version-properties.json of the OCFL object could have the following entry: { \"v1\" : { \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\" } }","title":"1. Simple property"},{"location":"object-version-properties/object-version-properties/#2-complex-property","text":"If the repository wants to record a complex object for a version, for instance that it has been deaccessioned, this could be done with a similar structure. The object-version-properties.json of the OCFL object might have the following entry: { \"v1\" : { \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\" }, \"v2\" : { \"User-Agent\" : \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\" , \"deaccessioned\" : { \"datetime\" : \"2025-10-15T13:19:00\" , \"reason\" : \"Deaccessioned because dataset was deleted in Easy\" } } } Note, that this example also demonstrates that a property that remains unchanged between versions (in this case \"User-Agent\") must be copied from the previous version.","title":"2. Complex property"},{"location":"packaging-format-registry/packaging-format-registry/","text":"OCFL Extension: Packaging Format Registry \u00b6 Extension Name: packaging-format-registry Authors: Linda Reijnhoudt, Jan van Mansum Minimum OCFL Version: 1.0 Status: DRAFT Overview \u00b6 In order for an OCFL repository to be self-contained, it may want to explicitly specify the packaging formats used to package the content of object versions. We broadly define \"packaging format\" as a set of rules about the way the content files of an OCFL object version are laid out, organized, and described. We describe a standard layout for a packaging format registry, similar to 0008-schema-registry , where this extension stores the specifications for the packaging formats used throughout the OCFL Repository. This packaging format registry must be implemented by creating and maintaining the following items: A config.json file containing the configuration parameters for the extension. A packaging_formats directory containing one subdirectory for each packaging format. A packaging_format_inventory.json file providing an index for the stored packaging format specifications. A sidecar file packaging_format_inventory.json.sha512 (or other configured digest) containing the digest of the packaging_format_inventory.json file, in the same manner as the OCFL inventory files. Parameters \u00b6 Configuration is done by setting values in the file config.json at the top level of the extension's directory. The keys expected are: Name: extensionName Description: String identifying the extension. Type: String. Constraints: Must be packaging-format-registry . Default: packaging-format-registry . Name: packagingFormatDigestAlgorithm Description: Algorithm used for calculating safe filenames from packaging formats. Type: String Constraints: Must be a valid digest algorithm returning strings which are safe file names on the target file system. Default: md5 . Name: digestAlgorithm Description: Digest algorithm used for calculating fixity of the packaging registry inventory stored in the sidecar file. Type: String. Constraints: Must be a valid digest algorithm. Default: The same value used elsewhere in the OCFL for integrity checking. The packaging_formats directory \u00b6 The packaging_formats directory is located in the top directory of the packaging-format-registry extension. Each packaging format is described in a subdirectory of this packaging_formats directory. The name of this subdirectory must be the hexadecimal serialization of the digest of the string: <name>/<version> , where <name> and <version> are the name and version of the packaging format as defined in the packaging_format_inventory.json (see below). The digest algorithm used to calculate this digest is defined in the config.json file under the key packagingFormatDigestAlgorithm . The subdirectory may include documentation, examples, machine actionable code and other information about the packaging format. How to interpret these files is outside the scope of this extension. The subdirectory may include other subdirectories, recursively. The packaging_format_inventory.json file \u00b6 A manifest of the registered packaging formats must be maintained in packaging_format_inventory.json . This is a JSON with as top-level key manifest , which contains an object with one entry per registered packaging format. Root object properties \u00b6 Name: manifest Description: Object containing manifest entries. Type: Object. Constraints: Must contain one entry per registered packaging format. The key of this entry is the digest of the string <name>/<version> ( see The packaging_formats directory above). The value of this entry is an object with the properties described below. Default: Not applicable. Manifest entry properties \u00b6 Name: name Description: The human-readable name of the packaging format. Type: String. Constraints: Not applicable. Default: Not applicable. Name: version Description: Version of this packaging format. Type: String. Constraints: The name and version together must be unique for the packaging formats in this storage root. Default: Not applicable. Name: summary Description: Short description of the packaging format. Type: String. Constraints: Not applicable. Default: Not applicable. Implementation \u00b6 Validation \u00b6 Clients that implement this extension must validate the following as part of the validation of the OCFL storage root: JSON files must be well-formed JSON and conform to the schemas specified in this document. Manifest entries must correspond one-to-one to the packaging formats in the packaging_formats directory. Name/version pairs must be unique across the manifest. Digest algorithms must be one of the algorithms supported by the OCFL specification. Registering a packaging format with the extension \u00b6 For each referenced packaging format in the OCFL object versions: The implementation must check if the packaging format is already registered in the packaging_format_inventory.json manifest. If the packaging format is not registered, the implementation must: Derive the digest of the string <name>/<version> using the packagingFormatDigestAlgorithm defined in the config.json . Create a subdirectory in the packaging_formats directory with the derived digest as its name. Store the documentation and other information about the packaging format in this subdirectory. Update the packaging_format_inventory.json manifest with a new entry for the packaging format, using the derived digest as the key and an object with the properties name , version , and summary as the value. Update the sidecar file packaging_format_inventory.json.sha512 (or other configured digest) with the new digest of the packaging_format_inventory.json file. The values of digestAlgorithm and packagingFormatDigestAlgorithm should not be changed once the registry is initialized. If changing the digest is unavoidable, all existing entries in the registry must be updated to the new algorithm(s). Referencing a packaging format in an OCFL object version \u00b6 An implementation can determine the packaging format used for an OCFL object version by finding the name and version of the packaging format used. How this is recorded is outside the scope of this extension, but one possible way is to use the DANS Object Version Properties extension to record the packaging format as a property of the object version. Other possibilities include using a designated version level metadata field, or a specific file in the object version content directory. Example \u00b6 The packaging_format_inventory.json file contains the manifest with the available OCFL Object Packaging Formats for this OCFL Repository. packaging_format_inventory.json { \"manifest\" : { \"76f773808534f2969d7a405b99e78b11\" : { \"name\" : \"BagIt\" , \"version\" : \"v0.97\" , \"summary\" : \"a hierarchical file packaging format for storage and transfer of arbitrary digital content.\" }, \"05b408a38e341de9bb4316aa812115ee\" : { \"name\" : \"BagIt\" , \"version\" : \"v1.0\" , \"summary\" : \"https://datatracker.ietf.org/doc/html/rfc8493\" } } } The storage root of the OCFL repository would then look something like this: [storage_root] \u251c\u2500\u2500 0=ocfl_1.0 \u251c\u2500\u2500 ocfl_1.0.txt \u251c\u2500\u2500 ocfl_layout.json \u2514\u2500\u2500 extensions \u2514\u2500\u2500 packaging-format-registry/ \u251c\u2500\u2500 config.json \u251c\u2500\u2500 packaging_format_inventory.json \u251c\u2500\u2500 packaging_format_inventory.json.sha512 \u2514\u2500\u2500 packaging_formats \u251c\u2500\u2500 05b408a38e341de9bb4316aa812115ee | \u251c\u2500\u2500 rfc8493.txt | \u2514\u2500\u2500 ... files describing the packaging_format BagIt/v1.0 ... \u2514\u2500\u2500 76f773808534f2969d7a405b99e78b11 \u2514\u2500\u2500 ... files describing the packaging_format BagIt/v0.97 ...","title":"Packaging Format Registry"},{"location":"packaging-format-registry/packaging-format-registry/#ocfl-extension-packaging-format-registry","text":"Extension Name: packaging-format-registry Authors: Linda Reijnhoudt, Jan van Mansum Minimum OCFL Version: 1.0 Status: DRAFT","title":"OCFL Extension: Packaging Format Registry"},{"location":"packaging-format-registry/packaging-format-registry/#overview","text":"In order for an OCFL repository to be self-contained, it may want to explicitly specify the packaging formats used to package the content of object versions. We broadly define \"packaging format\" as a set of rules about the way the content files of an OCFL object version are laid out, organized, and described. We describe a standard layout for a packaging format registry, similar to 0008-schema-registry , where this extension stores the specifications for the packaging formats used throughout the OCFL Repository. This packaging format registry must be implemented by creating and maintaining the following items: A config.json file containing the configuration parameters for the extension. A packaging_formats directory containing one subdirectory for each packaging format. A packaging_format_inventory.json file providing an index for the stored packaging format specifications. A sidecar file packaging_format_inventory.json.sha512 (or other configured digest) containing the digest of the packaging_format_inventory.json file, in the same manner as the OCFL inventory files.","title":"Overview"},{"location":"packaging-format-registry/packaging-format-registry/#parameters","text":"Configuration is done by setting values in the file config.json at the top level of the extension's directory. The keys expected are: Name: extensionName Description: String identifying the extension. Type: String. Constraints: Must be packaging-format-registry . Default: packaging-format-registry . Name: packagingFormatDigestAlgorithm Description: Algorithm used for calculating safe filenames from packaging formats. Type: String Constraints: Must be a valid digest algorithm returning strings which are safe file names on the target file system. Default: md5 . Name: digestAlgorithm Description: Digest algorithm used for calculating fixity of the packaging registry inventory stored in the sidecar file. Type: String. Constraints: Must be a valid digest algorithm. Default: The same value used elsewhere in the OCFL for integrity checking.","title":"Parameters"},{"location":"packaging-format-registry/packaging-format-registry/#the-packaging_formats-directory","text":"The packaging_formats directory is located in the top directory of the packaging-format-registry extension. Each packaging format is described in a subdirectory of this packaging_formats directory. The name of this subdirectory must be the hexadecimal serialization of the digest of the string: <name>/<version> , where <name> and <version> are the name and version of the packaging format as defined in the packaging_format_inventory.json (see below). The digest algorithm used to calculate this digest is defined in the config.json file under the key packagingFormatDigestAlgorithm . The subdirectory may include documentation, examples, machine actionable code and other information about the packaging format. How to interpret these files is outside the scope of this extension. The subdirectory may include other subdirectories, recursively.","title":"The packaging_formats directory"},{"location":"packaging-format-registry/packaging-format-registry/#the-packaging_format_inventoryjson-file","text":"A manifest of the registered packaging formats must be maintained in packaging_format_inventory.json . This is a JSON with as top-level key manifest , which contains an object with one entry per registered packaging format.","title":"The packaging_format_inventory.json file"},{"location":"packaging-format-registry/packaging-format-registry/#root-object-properties","text":"Name: manifest Description: Object containing manifest entries. Type: Object. Constraints: Must contain one entry per registered packaging format. The key of this entry is the digest of the string <name>/<version> ( see The packaging_formats directory above). The value of this entry is an object with the properties described below. Default: Not applicable.","title":"Root object properties"},{"location":"packaging-format-registry/packaging-format-registry/#manifest-entry-properties","text":"Name: name Description: The human-readable name of the packaging format. Type: String. Constraints: Not applicable. Default: Not applicable. Name: version Description: Version of this packaging format. Type: String. Constraints: The name and version together must be unique for the packaging formats in this storage root. Default: Not applicable. Name: summary Description: Short description of the packaging format. Type: String. Constraints: Not applicable. Default: Not applicable.","title":"Manifest entry properties"},{"location":"packaging-format-registry/packaging-format-registry/#implementation","text":"","title":"Implementation"},{"location":"packaging-format-registry/packaging-format-registry/#validation","text":"Clients that implement this extension must validate the following as part of the validation of the OCFL storage root: JSON files must be well-formed JSON and conform to the schemas specified in this document. Manifest entries must correspond one-to-one to the packaging formats in the packaging_formats directory. Name/version pairs must be unique across the manifest. Digest algorithms must be one of the algorithms supported by the OCFL specification.","title":"Validation"},{"location":"packaging-format-registry/packaging-format-registry/#registering-a-packaging-format-with-the-extension","text":"For each referenced packaging format in the OCFL object versions: The implementation must check if the packaging format is already registered in the packaging_format_inventory.json manifest. If the packaging format is not registered, the implementation must: Derive the digest of the string <name>/<version> using the packagingFormatDigestAlgorithm defined in the config.json . Create a subdirectory in the packaging_formats directory with the derived digest as its name. Store the documentation and other information about the packaging format in this subdirectory. Update the packaging_format_inventory.json manifest with a new entry for the packaging format, using the derived digest as the key and an object with the properties name , version , and summary as the value. Update the sidecar file packaging_format_inventory.json.sha512 (or other configured digest) with the new digest of the packaging_format_inventory.json file. The values of digestAlgorithm and packagingFormatDigestAlgorithm should not be changed once the registry is initialized. If changing the digest is unavoidable, all existing entries in the registry must be updated to the new algorithm(s).","title":"Registering a packaging format with the extension"},{"location":"packaging-format-registry/packaging-format-registry/#referencing-a-packaging-format-in-an-ocfl-object-version","text":"An implementation can determine the packaging format used for an OCFL object version by finding the name and version of the packaging format used. How this is recorded is outside the scope of this extension, but one possible way is to use the DANS Object Version Properties extension to record the packaging format as a property of the object version. Other possibilities include using a designated version level metadata field, or a specific file in the object version content directory.","title":"Referencing a packaging format in an OCFL object version"},{"location":"packaging-format-registry/packaging-format-registry/#example","text":"The packaging_format_inventory.json file contains the manifest with the available OCFL Object Packaging Formats for this OCFL Repository. packaging_format_inventory.json { \"manifest\" : { \"76f773808534f2969d7a405b99e78b11\" : { \"name\" : \"BagIt\" , \"version\" : \"v0.97\" , \"summary\" : \"a hierarchical file packaging format for storage and transfer of arbitrary digital content.\" }, \"05b408a38e341de9bb4316aa812115ee\" : { \"name\" : \"BagIt\" , \"version\" : \"v1.0\" , \"summary\" : \"https://datatracker.ietf.org/doc/html/rfc8493\" } } } The storage root of the OCFL repository would then look something like this: [storage_root] \u251c\u2500\u2500 0=ocfl_1.0 \u251c\u2500\u2500 ocfl_1.0.txt \u251c\u2500\u2500 ocfl_layout.json \u2514\u2500\u2500 extensions \u2514\u2500\u2500 packaging-format-registry/ \u251c\u2500\u2500 config.json \u251c\u2500\u2500 packaging_format_inventory.json \u251c\u2500\u2500 packaging_format_inventory.json.sha512 \u2514\u2500\u2500 packaging_formats \u251c\u2500\u2500 05b408a38e341de9bb4316aa812115ee | \u251c\u2500\u2500 rfc8493.txt | \u2514\u2500\u2500 ... files describing the packaging_format BagIt/v1.0 ... \u2514\u2500\u2500 76f773808534f2969d7a405b99e78b11 \u2514\u2500\u2500 ... files describing the packaging_format BagIt/v0.97 ...","title":"Example"},{"location":"property-registry/property-registry/","text":"OCFL Extension: Property Registry \u00b6 Extension Name: property-registry Authors: Linda Reijnhoudt, Jan van Mansum Minimum OCFL Version: 1.0 Status: DRAFT Overview \u00b6 This extension facilitates a way to define properties for an OCFL object. The registry described here only maintains a list of properties that could be used, and their definitions and structures. It does not prescribe how these properties are associated with items in the repository, such as object versions. One way to associate properties with object versions is to use the Object Version Properties extension . Parameters \u00b6 Configuration is done by setting values in the file config.json at the top level of the extension's directory. The expected keys are: Name: extensionName Description: String identifying the extension. Type: String. Constraints: Must be property-registry . Default: property-registry . Name: propertyRegistry Description: An object with as keys the names of the properties, and as values property description entries as defined below. Type: Object. Constraints: The values must have at least the required properties as described below, at most extended with the optional properties. Default: Empty array. Property description values \u00b6 Name: description Description: A human-readable description of the property, explaining its purpose and usage. Type: String. Constraints: None. Required: true. Default: None. Name: type Description: The JSON type of the property. Type: String. Constraints: Must be one of: number , string , boolean or object . If object , the property must have a properties key defined. Required: true. Default: string . Name: constraints Description: A human-readable description of the constraints on the property value, if any. Type: String. Constraints: None. Required: false. Default: None. Name: properties Description: If the property is of type object , this key must be present and contain an object that has as keys the names of the properties of the object, and as values property description values as defined in this paragraph. Type: Object. Constraints: Each value in the object must be a property description value as defined in this paragraph. Required: if type is object . Default: None. Name: required Description: A boolean indicating whether this property is required. Type: Boolean. Constraints: None. Required: false. Default: false. Name: default Description: The default value for the property, if any. Type: Any valid JSON value of the type defined by the type key. Constraints: Must be a valid value for the property type. May not be present if required is true. Required: false. Default: None. Note, that the array type is not supported, as this would make validation of the property values more complex. The properties defined by means of this extension are intended to be fairly simple, and not to be used for complex data structures, which are better stored in the content files of the OCFL object. Note also, that this extension does not define a generic way to validate the property values against the constraints. Implementation \u00b6 Validation \u00b6 As part of the validation of the storage root, implementing software must check that the config.json is well-formed and contains the required keys and values as described above. It must also check that no other keys are present in the config.json file. Registering a property with the property registry \u00b6 In order to register a property with the property registry, the implementing software must update the config.json file in the property-registry extension directory with a new property description entry. Examples \u00b6 The following example registry contains three properties, each demonstrating a different use case. The registry is stored in the property-registry/config.json file in the extensions/property-registry directory of the OCFL storage root. [storage_root] \u251c\u2500\u2500 0=ocfl_1.0 \u251c\u2500\u2500 ocfl_1.0.txt \u251c\u2500\u2500 ocfl_layout.json \u251c\u2500\u2500 property-registry.md \u251c\u2500\u2500 extensions | \u2514\u2500\u2500 property-registry/ | \u2514\u2500\u2500 config.json with the following content for property-registry/config.json : { \"extensionName\" : \"property-registry\" , \"propertyRegistry\" : { \"retentionEndDate\" : { \"description\" : \"the date until which this object version may be retained in this repository\" , \"type\" : \"string\" , \"constraint\" : \"a date in ISO 8601 format, e.g. 2030-10-01\" , \"required\" : false }, \"deaccessioned\" : { \"description\" : \"If present, this version of the object has been deaccessioned and should not be disseminated\" , \"type\" : \"object\" , \"required\" : false , \"properties\" : [ { \"name\" : \"datetime\" , \"description\" : \"The date on which this object version has been deaccessioned\" , \"type\" : \"string\" , \"constraint\" : \"a datetime in ISO 8601 YYYY-MM-DDTHH-mm-ss format\" , \"required\" : true }, { \"name\" : \"reason\" , \"description\" : \"The reason why this object version has been deaccessioned.\" , \"type\" : \"string\" , \"required\" : true } ] } }, \"packagingFormat\" : { \"description\" : \"The packaging format of the current object version, as defined in the packaging-format-registry\" , \"type\" : \"string\" , \"required\" : true }, \"personalDataPresent\" : { \"description\" : \"Indicates whether this object version contains personal data\" , \"type\" : \"string\" , \"constraint\" : \"One of: 'yes', 'no', 'unknown'\" , \"required\" : false , \"default\" : \"unknown\" } } retentionEndDate property \u00b6 This is a simple string property that indicates the date until which this object version must be retained in the repository. It is required and must be in ISO 8601 format. deaccessioned property \u00b6 This is a structured property that doubles as a boolean flag. If present, it indicates that this object version has been deaccessioned and should not be disseminated. It also documents the date and reason for deaccessioning. packagingFormat property \u00b6 This is a simple string property that indicates the packaging format of the current object version as defined in the Packaging Format Registry extension . It is required and must be a valid packaging format name as defined in that registry. personalDataPresent property \u00b6 This is a simple string property that indicates whether this object version contains personal data. It is not required and defaults to \"unknown\".","title":"Property Registry"},{"location":"property-registry/property-registry/#ocfl-extension-property-registry","text":"Extension Name: property-registry Authors: Linda Reijnhoudt, Jan van Mansum Minimum OCFL Version: 1.0 Status: DRAFT","title":"OCFL Extension: Property Registry"},{"location":"property-registry/property-registry/#overview","text":"This extension facilitates a way to define properties for an OCFL object. The registry described here only maintains a list of properties that could be used, and their definitions and structures. It does not prescribe how these properties are associated with items in the repository, such as object versions. One way to associate properties with object versions is to use the Object Version Properties extension .","title":"Overview"},{"location":"property-registry/property-registry/#parameters","text":"Configuration is done by setting values in the file config.json at the top level of the extension's directory. The expected keys are: Name: extensionName Description: String identifying the extension. Type: String. Constraints: Must be property-registry . Default: property-registry . Name: propertyRegistry Description: An object with as keys the names of the properties, and as values property description entries as defined below. Type: Object. Constraints: The values must have at least the required properties as described below, at most extended with the optional properties. Default: Empty array.","title":"Parameters"},{"location":"property-registry/property-registry/#property-description-values","text":"Name: description Description: A human-readable description of the property, explaining its purpose and usage. Type: String. Constraints: None. Required: true. Default: None. Name: type Description: The JSON type of the property. Type: String. Constraints: Must be one of: number , string , boolean or object . If object , the property must have a properties key defined. Required: true. Default: string . Name: constraints Description: A human-readable description of the constraints on the property value, if any. Type: String. Constraints: None. Required: false. Default: None. Name: properties Description: If the property is of type object , this key must be present and contain an object that has as keys the names of the properties of the object, and as values property description values as defined in this paragraph. Type: Object. Constraints: Each value in the object must be a property description value as defined in this paragraph. Required: if type is object . Default: None. Name: required Description: A boolean indicating whether this property is required. Type: Boolean. Constraints: None. Required: false. Default: false. Name: default Description: The default value for the property, if any. Type: Any valid JSON value of the type defined by the type key. Constraints: Must be a valid value for the property type. May not be present if required is true. Required: false. Default: None. Note, that the array type is not supported, as this would make validation of the property values more complex. The properties defined by means of this extension are intended to be fairly simple, and not to be used for complex data structures, which are better stored in the content files of the OCFL object. Note also, that this extension does not define a generic way to validate the property values against the constraints.","title":"Property description values"},{"location":"property-registry/property-registry/#implementation","text":"","title":"Implementation"},{"location":"property-registry/property-registry/#validation","text":"As part of the validation of the storage root, implementing software must check that the config.json is well-formed and contains the required keys and values as described above. It must also check that no other keys are present in the config.json file.","title":"Validation"},{"location":"property-registry/property-registry/#registering-a-property-with-the-property-registry","text":"In order to register a property with the property registry, the implementing software must update the config.json file in the property-registry extension directory with a new property description entry.","title":"Registering a property with the property registry"},{"location":"property-registry/property-registry/#examples","text":"The following example registry contains three properties, each demonstrating a different use case. The registry is stored in the property-registry/config.json file in the extensions/property-registry directory of the OCFL storage root. [storage_root] \u251c\u2500\u2500 0=ocfl_1.0 \u251c\u2500\u2500 ocfl_1.0.txt \u251c\u2500\u2500 ocfl_layout.json \u251c\u2500\u2500 property-registry.md \u251c\u2500\u2500 extensions | \u2514\u2500\u2500 property-registry/ | \u2514\u2500\u2500 config.json with the following content for property-registry/config.json : { \"extensionName\" : \"property-registry\" , \"propertyRegistry\" : { \"retentionEndDate\" : { \"description\" : \"the date until which this object version may be retained in this repository\" , \"type\" : \"string\" , \"constraint\" : \"a date in ISO 8601 format, e.g. 2030-10-01\" , \"required\" : false }, \"deaccessioned\" : { \"description\" : \"If present, this version of the object has been deaccessioned and should not be disseminated\" , \"type\" : \"object\" , \"required\" : false , \"properties\" : [ { \"name\" : \"datetime\" , \"description\" : \"The date on which this object version has been deaccessioned\" , \"type\" : \"string\" , \"constraint\" : \"a datetime in ISO 8601 YYYY-MM-DDTHH-mm-ss format\" , \"required\" : true }, { \"name\" : \"reason\" , \"description\" : \"The reason why this object version has been deaccessioned.\" , \"type\" : \"string\" , \"required\" : true } ] } }, \"packagingFormat\" : { \"description\" : \"The packaging format of the current object version, as defined in the packaging-format-registry\" , \"type\" : \"string\" , \"required\" : true }, \"personalDataPresent\" : { \"description\" : \"Indicates whether this object version contains personal data\" , \"type\" : \"string\" , \"constraint\" : \"One of: 'yes', 'no', 'unknown'\" , \"required\" : false , \"default\" : \"unknown\" } }","title":"Examples"},{"location":"property-registry/property-registry/#retentionenddate-property","text":"This is a simple string property that indicates the date until which this object version must be retained in the repository. It is required and must be in ISO 8601 format.","title":"retentionEndDate property"},{"location":"property-registry/property-registry/#deaccessioned-property","text":"This is a structured property that doubles as a boolean flag. If present, it indicates that this object version has been deaccessioned and should not be disseminated. It also documents the date and reason for deaccessioning.","title":"deaccessioned property"},{"location":"property-registry/property-registry/#packagingformat-property","text":"This is a simple string property that indicates the packaging format of the current object version as defined in the Packaging Format Registry extension . It is required and must be a valid packaging format name as defined in that registry.","title":"packagingFormat property"},{"location":"property-registry/property-registry/#personaldatapresent-property","text":"This is a simple string property that indicates whether this object version contains personal data. It is not required and defaults to \"unknown\".","title":"personalDataPresent property"}]}